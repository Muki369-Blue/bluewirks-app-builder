"""Generator module for BlueWirks App Builder.

This module provides functions to generate code scaffolds from user prompts and
selected templates, write those scaffolds to a temporary directory, and
optionally deploy the backend or UI portions to various hosting providers.

The module is designed to be lightweight with a few external dependencies:
* ``transformers`` for running the phi-3-mini-128k-instruct model to generate
  code. The model is loaded lazily so that it only initializes when needed.
* ``huggingface_hub`` for deploying to Hugging Face Spaces.

Deploy functions for Render and Vercel are provided as stubs. They illustrate
how you would call out to these services using their respective APIs. You need
to supply appropriate API keys and extend the implementations if you want
fully automated deployment.
"""

import os
import zipfile
import tempfile
import json
from typing import Optional

from transformers import pipeline

# Initialize the text-generation pipeline once at import time.  Depending on
# your environment, you may want to control device placement or caching.
pipe = pipeline(
    "text-generation",
    model="microsoft/phi-3-mini-128k-instruct",
    torch_dtype="auto",
    device_map="auto",
)

# System prompt to guide code generation. The template and tags fields are
# interpolated into the prompt below in `generate_scaffold`.
SYSTEM_PROMPT = """You are an AI app scaffolding generator.
Given a user's idea and preferred template, produce a concise, functional code
scaffold:
 - Support templates: Streamlit (Python), React (JS), or FastAPI (Python)
 - Provide a README and minimal working code.
 - Do NOT include placeholder text like <insert>.
Return code as plain text with file names and code blocks."""

# README template that will be added to every generated project. This includes
# an architecture diagram, API reference placeholder, and local dev instructions.
README_TEMPLATE = """# Generated App

This project was generated by BlueWirks App Builder.

## Architecture

```mermaid
graph TD
    User --> Frontend
    Frontend --> Backend
    Backend --> DB[(Database)]
```

## API Reference

All API endpoints are defined in the backend module of the scaffold. Refer
to the generated code for details.

## Local Development

Install the dependencies and run the backend:

```bash
pip install -r requirements.txt
python backend/main.py
```

If your project contains a React frontend, install dependencies and start
the development server in another terminal:

```bash
cd frontend
npm install
npm run dev
```
"""

# Pre-commit configuration for automatic formatting and linting.
PRE_COMMIT_CONFIG = """
repos:
  - repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
      - id: black
  - repo: https://github.com/charliermarsh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
  - repo: https://github.com/pre-commit/mirrors-prettier
    rev: v3.1.0
    hooks:
      - id: prettier
        additional_dependencies: [prettier@3.1.0]
"""

# ESLint configuration for JS/TS projects. Adjust as needed.
ESLINT_CONFIG = {
    "env": {
        "browser": True,
        "es2021": True,
    },
    "extends": ["eslint:recommended", "plugin:react/recommended"],
    "parserOptions": {
        "ecmaFeatures": {"jsx": True},
        "ecmaVersion": 12,
        "sourceType": "module",
    },
    "rules": {},
}

# Prettier configuration. Keep it minimal to allow user overrides.
PRETTIER_CONFIG = {
    "semi": True,
    "singleQuote": True,
    "printWidth": 80,
}


def generate_scaffold(
    user_prompt: str,
    template: str,
    tags: str = "",
    blueprint: str = "",
    languages: str = "",
    theme: str = "",
    include_db: bool = False,
    include_deployment: bool = False,
    csv_preview: str = "",
    schema_desc: str = "",
) -> str:
    """Generate a code scaffold from the given parameters.

    This function calls the underlying language model with a rich prompt that
    incorporates optional blueprint selections (e.g. chatbot engine, CRUD
    admin builder), target languages, theme preferences, database integration,
    deployment script inclusion, and previews of uploaded CSVs or schema
    descriptions. These additional parameters allow the model to tailor the
    scaffold to the user's needs.

    Args:
        user_prompt: Description of the app idea.
        template: Chosen template (Streamlit, React, or FastAPI).
        tags: Optional comma‑separated tags for metadata.
        blueprint: Optional blueprint to guide generation (e.g. "Chatbot engine").
        languages: Comma‑separated list of languages for i18n support.
        theme: Name of a theme or brand selection.
        include_db: Whether to include preconfigured database integration.
        include_deployment: Whether to include deployment scripts (AWS/GCP).
        csv_preview: A short preview of an uploaded CSV (e.g. header row).
        schema_desc: A text description of a data schema supplied by the user.

    Returns:
        str: The generated scaffold as plain text.
    """
    # Build an extended prompt for the language model. Each optional field is
    # included only if provided or True. This allows the model to condition
    # its output on the user's choices without hardcoding behaviours.
    prompt_parts = [
        SYSTEM_PROMPT,
        "",
        f"User idea: {user_prompt}",
        f"Template: {template}",
    ]
    if blueprint:
        prompt_parts.append(f"Blueprint: {blueprint}")
    if languages:
        prompt_parts.append(f"Languages: {languages}")
    if theme:
        prompt_parts.append(f"Theme: {theme}")
    if include_db:
        prompt_parts.append("Include database integration: Yes")
    if include_deployment:
        prompt_parts.append("Include deployment scripts: Yes")
    if csv_preview:
        prompt_parts.append(f"CSV Preview: {csv_preview}")
    if schema_desc:
        prompt_parts.append(f"Schema: {schema_desc}")
    if tags:
        prompt_parts.append(f"Tags: {tags}")
    prompt_parts.append("\nCode scaffold:")
    full_prompt = "\n\n".join(prompt_parts)
    result = pipe(full_prompt, max_new_tokens=1600)
    return result[0]["generated_text"]


def write_zip(
    scaffold_text: str,
    tags: str = "",
    blueprint: str = "",
    languages: str = "",
    theme: str = "",
    include_db: bool = False,
    include_deployment: bool = False,
) -> str:
    """Write the scaffold text and additional files to a zip archive.

    This function creates a temporary directory, writes the scaffold text to
    ``scaffold.txt`` and adds a README.md and other configuration files. If
    tags are provided, they are saved into a ``metadata.json`` file. Additional
    files are generated based on the blueprint, languages, theme, database
    integration, and deployment script options.

    Args:
        scaffold_text: The generated scaffold text.
        tags: Optional comma‑separated tags for metadata.
        blueprint: The blueprint selected by the user.
        languages: Languages for internationalization support.
        theme: Selected theme or brand.
        include_db: Whether to include a database configuration file.
        include_deployment: Whether to include deployment scripts for AWS/GCP.

    Returns:
        The absolute path to the created zip archive.
    """
    temp_dir = tempfile.mkdtemp()
    # Write the raw scaffold text
    scaffold_path = os.path.join(temp_dir, "scaffold.txt")
    with open(scaffold_path, "w") as f:
        f.write(scaffold_text)

    # Write README
    readme_path = os.path.join(temp_dir, "README.md")
    with open(readme_path, "w") as f:
        f.write(README_TEMPLATE)

    # Write pre-commit config
    pre_commit_path = os.path.join(temp_dir, ".pre-commit-config.yaml")
    with open(pre_commit_path, "w") as f:
        f.write(PRE_COMMIT_CONFIG)

    # Write ESLint and Prettier configs as JSON files
    eslint_path = os.path.join(temp_dir, ".eslintrc.json")
    with open(eslint_path, "w") as f:
        json.dump(ESLINT_CONFIG, f, indent=2)
    prettier_path = os.path.join(temp_dir, ".prettierrc")
    with open(prettier_path, "w") as f:
        json.dump(PRETTIER_CONFIG, f, indent=2)

    # Additional optional files
    # Metadata
    if tags:
        meta_path = os.path.join(temp_dir, "metadata.json")
        with open(meta_path, "w") as f:
            json.dump({"tags": [t.strip() for t in tags.split(",") if t]}, f)
    # Blueprint info
    if blueprint or languages or theme:
        info_path = os.path.join(temp_dir, "project_info.json")
        with open(info_path, "w") as f:
            json.dump(
                {
                    "blueprint": blueprint,
                    "languages": [lang.strip() for lang in languages.split(",") if lang],
                    "theme": theme,
                },
                f,
                indent=2,
            )
    # DB configuration
    if include_db:
        db_config_path = os.path.join(temp_dir, "db_config.json")
        with open(db_config_path, "w") as f:
            json.dump(
                {
                    "database": "sqlite",
                    "uri": "sqlite:///app.db",
                },
                f,
                indent=2,
            )
    # Deployment scripts for AWS and GCP
    if include_deployment:
        aws_path = os.path.join(temp_dir, "deploy_aws.sh")
        with open(aws_path, "w") as f:
            f.write(
                "#!/bin/bash\n"
                "# Placeholder AWS deployment script generated by BlueWirks\n"
                "echo 'Deploying to AWS...'\n"
                "# Add your AWS deployment commands here\n"
            )
        gcp_path = os.path.join(temp_dir, "deploy_gcp.sh")
        with open(gcp_path, "w") as f:
            f.write(
                "#!/bin/bash\n"
                "# Placeholder GCP deployment script generated by BlueWirks\n"
                "echo 'Deploying to GCP...'\n"
                "# Add your GCP deployment commands here\n"
            )
        # Make scripts executable
        os.chmod(aws_path, 0o755)
        os.chmod(gcp_path, 0o755)

    # Environment example file for secrets and variables
    env_example_path = os.path.join(temp_dir, ".env.example")
    with open(env_example_path, "w") as f:
        f.write(
            "# Environment variables for your generated app\n"
            "SECRET_KEY=replace_me\n"
            "DATABASE_URL=sqlite:///app.db\n"
        )

    # Create zip archive
    zip_path = os.path.join(temp_dir, "scaffold.zip")
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf:
        zipf.write(scaffold_path, arcname="scaffold.txt")
        zipf.write(readme_path, arcname="README.md")
        zipf.write(pre_commit_path, arcname=".pre-commit-config.yaml")
        zipf.write(eslint_path, arcname=".eslintrc.json")
        zipf.write(prettier_path, arcname=".prettierrc")
        zipf.write(env_example_path, arcname=".env.example")
        if tags:
            zipf.write(meta_path, arcname="metadata.json")
        if blueprint or languages or theme:
            zipf.write(info_path, arcname="project_info.json")
        if include_db:
            zipf.write(db_config_path, arcname="db_config.json")
        if include_deployment:
            zipf.write(aws_path, arcname="deploy_aws.sh")
            zipf.write(gcp_path, arcname="deploy_gcp.sh")
    return zip_path


def deploy_to_hf(scaffold_dir: str, space_name: str, hf_token: str, username: str) -> str:
    """Deploy a generated scaffold to a new Hugging Face Space.

    This function uses the huggingface_hub library to create a Space and
    upload the scaffold directory. It returns the URL of the new Space.

    Args:
        scaffold_dir (str): the path to the scaffold directory (zip or extracted).
        space_name (str): the desired name of the Hugging Face Space.
        hf_token (str): a user access token with write permission.
        username (str): the Hugging Face username for the target account.

    Returns:
        str: the URL of the created Space.
    """
    from huggingface_hub import HfApi

    api = HfApi(token=hf_token)
    repo_id = f"spaces/{username}/{space_name}"
    api.create_repo(repo_id, repo_type="space", space_sdk="gradio")
    api.upload_folder(folder_path=scaffold_dir, repo_id=repo_id, repo_type="space")
    return f"https://huggingface.co/spaces/{username}/{space_name}"


def deploy_to_render(scaffold_dir: str, service_name: str, api_key: str) -> str:
    """Deploy the backend to Render (stub implementation).

    Render offers a REST API to create services. This function is a placeholder
    that would make the necessary API calls using the provided API key and
    service name. You should implement calls to Render's API here.

    Args:
        scaffold_dir (str): path to the scaffold directory.
        service_name (str): the name of the service to create on Render.
        api_key (str): a Render API key.

    Returns:
        str: the URL of the deployed service (placeholder).
    """
    # TODO: Implement actual API calls to Render.
    # This placeholder simply constructs a fake URL for demonstration.
    return f"https://render.com/{service_name}"


def deploy_ui_to_vercel(scaffold_dir: str, project_name: str, token: str) -> str:
    """Deploy the frontend/UI to Vercel (stub implementation).

    Vercel exposes a REST API as well as a CLI. Use the provided token to
    authenticate and push your frontend directory. This stub returns a
    placeholder URL.

    Args:
        scaffold_dir (str): path to the scaffold directory.
        project_name (str): the Vercel project name to create.
        token (str): a Vercel personal token with write access.

    Returns:
        str: the URL of the deployed project (placeholder).
    """
    # TODO: Implement actual API calls to Vercel.
    # This placeholder simply constructs a fake URL for demonstration.
    return f"https://{project_name}.vercel.app"